apply plugin: 'com.android.application'

android {
    compileSdkVersion rootProject.ext.android_const.compileSdkVersion
    buildToolsVersion rootProject.ext.android_const.buildToolsVersion

    defaultConfig {
        applicationId rootProject.ext.android_const.packageName
        minSdkVersion rootProject.ext.android_const.minSdkVersion
        targetSdkVersion rootProject.ext.android_const.targetSdkVersion

        //project.hasProperty()方法是从同级目录下的gradle.properties文件里拿值
        //(一定要返回整数类型,不然会被versionCode认为成方法)
        if (project.hasProperty('VERSION_CODE')) {
            versionCode GetVersionCode(VERSION_CODE)
        }else{
            versionCode 1
        }

        //project.hasProperty()方法是从同级目录下的gradle.properties文件里拿值
        if (project.hasProperty('VERSION_NAME')) {
            versionName GetVersionName(VERSION_NAME)
        }else{
            versionName '1.1.1'
        }

        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
        flavorDimensions "versionCode"
    }

    signingConfigs {

        debug {
            keyAlias 'debug'
            keyPassword '123456'
            storeFile file('../keystore/debug/debug.jks')
            storePassword '123456'

        }

        release {
            keyAlias "release"
            keyPassword "112233"
            storeFile file('../keystore/release/release.jks')
            storePassword "112233"
        }

    }

    buildTypes {
        release {
            debuggable false
            jniDebuggable false
            minifyEnabled false      //混淆编译
            //minifyEnabled true      //混淆编译
            zipAlignEnabled true    //设置是否对APK包执行ZIP对齐优化
            shrinkResources false    //移除无用的资源文件

            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'

            signingConfig signingConfigs.release
        }

        debug {
            minifyEnabled false
            zipAlignEnabled false
            shrinkResources false

            signingConfig signingConfigs.debug
        }

    }

    productFlavors {

        prod {
            buildConfigField("String", "API_HOST", "\"https://\"")

            resValue "string", "app_name", "SelfApp_prod"
        }


        dev {
            buildConfigField("String", "API_HOST", "\"http://\"")

            resValue "string", "app_name", "SelfApp_dev"
        }

    }

    lintOptions {
        // 设置为 true时lint将不报告分析的进度
        quiet true
        // 如果为 true，则当lint发现错误时停止 gradle构建
        abortOnError false
        // 如果为 true，则只报告错误
        ignoreWarnings true
        // 如果为 true，则当有错误时会显示文件的全路径或绝对路径 (默认情况下为true)
        //absolutePaths true
        // 如果为 true，则检查所有的问题，包括默认不检查问题
        checkAllWarnings true
        // 如果为 true，则将所有警告视为错误
        warningsAsErrors true
        // 不检查给定的问题id
        disable 'TypographyFractions','TypographyQuotes'
        // 检查给定的问题 id
        enable 'RtlHardcoded','RtlCompat', 'RtlEnabled'
        // * 仅 * 检查给定的问题 id
        check 'NewApi', 'InlinedApi'
        // 如果为true，则在错误报告的输出中不包括源代码行
        noLines true
        // 如果为 true，则对一个错误的问题显示它所在的所有地方，而不会截短列表，等等。
        showAll true
        // 重置 lint 配置（使用默认的严重性等设置）。
        lintConfig file("default-lint.xml")
        // 如果为 true，生成一个问题的纯文本报告（默认为false）
        textReport true
        // 配置写入输出结果的位置；它可以是一个文件或 “stdout”（标准输出）
        textOutput 'stdout'
        // 如果为真，会生成一个XML报告，以给Jenkins之类的使用
        xmlReport false
        // 用于写入报告的文件（如果不指定，默认为lint-results.xml）
        xmlOutput file("lint-report.xml")
        // 如果为真，会生成一个HTML报告（包括问题的解释，存在此问题的源码，等等）
        htmlReport true
        // 写入报告的路径，它是可选的（默认为构建目录下的 lint-results.html ）
        htmlOutput file("lint-report.html")

        // 设置为 true， 将使所有release 构建都以issus的严重性级别为fatal（severity=false）的设置来运行lint
        // 并且，如果发现了致命（fatal）的问题，将会中止构建（由上面提到的 abortOnError 控制）
        checkReleaseBuilds true
        // 设置给定问题的严重级别（severity）为fatal （这意味着他们将会
        // 在release构建的期间检查 （即使 lint 要检查的问题没有包含在代码中)
        fatal 'NewApi', 'InlineApi'
        // 设置给定问题的严重级别为error
        error 'Wakelock', 'TextViewEdits'
        // 设置给定问题的严重级别为warning
        warning 'ResourceAsColor'
        // 设置给定问题的严重级别（severity）为ignore （和不检查这个问题一样）
        ignore 'TypographyQuotes'
    }

}




dependencies {
    implementation fileTree(include: ['*.jar'], dir: 'libs')
    implementation 'com.android.support.constraint:constraint-layout:1.1.3'
    implementation 'com.android.support:design:28.0.0'
    implementation 'com.android.support:support-v4:28.0.0'
    androidTestImplementation('com.android.support.test.espresso:espresso-core:2.2.2', {
        exclude group: 'com.android.support', module: 'support-annotations'
    })
    implementation 'com.android.support:appcompat-v7:28.0.0'
    //添加友盟追踪
    implementation 'com.umeng.analytics:analytics:latest.integration'
    testImplementation 'junit:junit:4.12'
//    apt 'com.jakewharton:butterknife-compiler:8.8.1'
    annotationProcessor 'com.jakewharton:butterknife-compiler:8.8.1'
    implementation 'com.google.code.gson:gson:2.8.2'
    implementation 'com.jakewharton:butterknife:8.8.1'
    implementation 'com.lzy.net:okgo:2.1.4'
    implementation 'com.squareup.okhttp3:okhttp:3.10.0'
//    annotationProcessor 'com.github.bumptech.glide:glide:4.8.0'
//    annotationProcessor 'com.github.bumptech.glide:compiler:4.8.0'
    implementation 'org.apache.commons:commons-collections4:4.1'
    implementation 'org.apache.commons:commons-lang3:3.5'

    implementation project(':libzxing')
    implementation project(':imageselector')
    implementation project(':landptf')
    implementation project(':niceimageview')
}


android.applicationVariants.all { variant ->
//批量修改Apk名字
    variant.outputs.all { output ->
        if (!variant.buildType.isDebuggable()) {
            //获取签名的名字 variant.signingConfig.name
            // 要被替换的源字符串
            def sourceFile = "-${variant.flavorName}-${variant.buildType.name}"
            def today = new Date().format('yyMMddHHmm')
            //替换的字符串
            def replaceFile = "_${variant.flavorName}_${variant.buildType.name}_V${variant.versionName}_${variant.versionCode}_${today}"
            outputFileName = output.outputFile.name.replace(sourceFile, replaceFile)
            //遗留问题：如何获取当前module的name，如CodeBooke这个名字怎么获取到
        }
    }
}

/*获取版本名字(一定要返回整数类型,不然会被versionCode认为成方法)*/
def GetVersionCode(String version_code) {
    java.lang.Integer my_number = Integer.valueOf(version_code)
    return my_number
}

/*获取版本名字*/
def GetVersionName(String version_name) {

//    char[]  version_name_char = String.format('%03d',Integer.parseInt(version_name)).toCharArray()
//
//    java.lang.StringBuffer stringBuffer = new StringBuffer()
//
//    stringBuffer.append(version_name_char[0])
//    stringBuffer.append('.')
//    stringBuffer.append(version_name_char[1])
//    stringBuffer.append('.')
//    stringBuffer.append(version_name_char[2])
//
//    println stringBuffer.toString()
//
//    return stringBuffer.toString()

    java.lang.String my_char = String.valueOf(version_name)
    return my_char
}